================================================================================
CATEGORY-PARTITION TESTING REPORT
Class: UtenteDAO
Package: model.dao
================================================================================

### 1. CLASS OVERVIEW

Class name: UtenteDAO
Package: model.dao

Role in the domain:
The UtenteDAO class is a Data Access Object responsible for managing database 
operations related to the Utente (User) entity. It provides operations to 
retrieve users (by ID, by email/password, all users), add new users, check 
email existence, and edit user profile information. It handles authentication 
and user management functionality.

Important fields:
- No instance fields (stateless DAO).
- Relies on ConPool for database connections.
- Manages utente table.
- Depends on OrdineDAO and RecensioneDAO for user relationships.

Invariants:
- Database connection must be properly managed.
- All database operations must handle SQLException appropriately.
- Parameter validation occurs before database operations.
- null parameters are rejected with IllegalArgumentException.
- ID parameters must be positive (> 0).
- Email and password must not be null or empty for authentication.
- Password is hashed using SHA1 in database.

================================================================================
### 2. METHODS TO BE TESTED
================================================================================

--------------------------------------------------------------------------------
#### 2.1 Constructor: UtenteDAO()
--------------------------------------------------------------------------------

2.1.1. Parameters and relevant state

Explicit parameters:
- None

Postconditions:
- A new UtenteDAO instance is created

2.1.2. Categories and choices

Category C1 - Constructor invocation
  C1.a: Constructor is called successfully

2.1.3. Test frames

F1: Create new UtenteDAO instance
  - Expected behavior: New instance created without exceptions

2.1.4. Suggested JUnit 5 test method names

shouldCreateNewUtenteDAOInstanceWhenConstructorCalled()
  - Arrange: None
  - Act: UtenteDAO dao = new UtenteDAO();
  - Assert: assertNotNull(dao)

2.1.5. Parameterized test candidates
- Not applicable

--------------------------------------------------------------------------------
#### 2.2 Method: public Utente getUtenteById(int id) throws SQLException
--------------------------------------------------------------------------------

2.2.1. Parameters and relevant state

Explicit parameters:
- id: int (the user ID to retrieve)

Relevant object state:
- Database connection availability
- Database state (utente table)

Preconditions:
- id must be > 0 (enforced by IllegalArgumentException)
- Database connection must be available

Postconditions:
- If user exists: Returns fully populated Utente with ordini and recensioni
- If user doesn't exist: Returns null
- Database connection is properly closed

2.2.2. Categories and choices

Category C1 - ID parameter
  C1.a: id <= 0 (invalid: zero)
  C1.b: id < 0 (invalid: negative)
  C1.c: id > 0 && user exists
  C1.d: id > 0 && user does NOT exist

Category C2 - Database state
  C2.a: User exists with ordini and recensioni
  C2.b: User exists without ordini and recensioni
  C2.c: User does not exist

Category C3 - Database connection
  C3.a: Connection is successfully obtained
  C3.b: Connection fails (SQLException)

Category C4 - DAO dependencies
  C4.a: OrdineDAO and RecensioneDAO calls succeed
  C4.b: OrdineDAO or RecensioneDAO calls fail

2.2.3. Test frames (combinations of choices)

F1: Get user with zero ID
  - Choices: C1.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message 
    "L'ID dell'utente deve essere maggiore di zero"

F2: Get user with negative ID
  - Choices: C1.b
  - Expected behavior: IllegalArgumentException is thrown

F3: Get existing user with ordini and recensioni
  - Choices: C1.c + C2.a + C3.a + C4.a
  - Expected behavior: Returns fully populated Utente
  - Return value: Utente with all fields, ordini, and recensioni
  - State: OrdineDAO and RecensioneDAO were called

F4: Get existing user without ordini and recensioni
  - Choices: C1.c + C2.b + C3.a + C4.a
  - Expected behavior: Returns Utente with empty lists
  - Return value: Utente with basic fields, empty ordini and recensioni

F5: Get non-existing user
  - Choices: C1.d + C2.c + C3.a
  - Expected behavior: Returns null
  - Return value: null

F6: Database connection fails
  - Choices: C1.c + C3.b
  - Expected behavior: SQLException is thrown

2.2.4. Suggested JUnit 5 test method names and structure

shouldThrowIllegalArgumentExceptionWhenIdIsZero()
  - Arrange: int id = 0;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.getUtenteById(id))
    - assertTrue(ex.getMessage().contains("maggiore di zero"))

shouldThrowIllegalArgumentExceptionWhenIdIsNegative()
  - Arrange: int id = -5;
  - Act & Assert: assertThrows(IllegalArgumentException.class, 
      () -> dao.getUtenteById(id))

shouldReturnFullyPopulatedUserWhenValidIdExists()
  - Arrange:
    - Insert user with ID 100
    - Insert ordini and recensioni for user
  - Act: Utente result = dao.getUtenteById(100);
  - Assert:
    - assertNotNull(result)
    - assertEquals(100, result.getId())
    - assertNotNull(result.getOrdini())
    - assertNotNull(result.getRecensioni())

shouldReturnUserWithEmptyCollectionsWhenUserHasNoOrdersOrReviews()
  - Arrange: Insert user with ID 100, no orders or reviews
  - Act: Utente result = dao.getUtenteById(100);
  - Assert:
    - assertNotNull(result)
    - assertNotNull(result.getOrdini())
    - assertEquals(0, result.getOrdini().size())

shouldReturnNullWhenUserDoesNotExist()
  - Arrange: Ensure user with ID 99999 does not exist
  - Act: Utente result = dao.getUtenteById(99999);
  - Assert: assertNull(result)

shouldThrowSQLExceptionWhenDatabaseConnectionFails()
  - Arrange: Mock ConPool to throw SQLException
  - Act & Assert: assertThrows(SQLException.class, () -> dao.getUtenteById(1))

2.2.5. Parameterized test candidates

Good for testing various invalid IDs:

CSV schema:
Columns: invalidId, description
Example rows:
  0, "zero ID"
  -1, "negative ID"
  -100, "large negative ID"

--------------------------------------------------------------------------------
#### 2.3 Method: public ArrayList<Utente> getUtenti() throws SQLException
--------------------------------------------------------------------------------

2.3.1. Parameters and relevant state

Explicit parameters:
- None

Relevant object state:
- Database connection availability
- Database state (utente table)

Preconditions:
- Database connection must be available

Postconditions:
- Returns ArrayList<Utente> containing all users
- Each Utente has basic fields populated (no ordini or recensioni)
- Empty list if no users exist
- Database connection is properly closed

2.3.2. Categories and choices

Category C1 - Database content
  C1.a: utente table is empty
  C1.b: utente table contains one user
  C1.c: utente table contains multiple users

Category C2 - Database connection
  C2.a: Connection is successfully obtained
  C2.b: Connection fails (SQLException)

Category C3 - SQL execution
  C3.a: SELECT executes successfully
  C3.b: SELECT fails (SQLException)

2.3.3. Test frames (combinations of choices)

F1: Retrieve all users from empty database
  - Choices: C1.a + C2.a + C3.a
  - Expected behavior: Returns empty ArrayList
  - Return value: Non-null, empty list (size == 0)

F2: Retrieve all users with one user in database
  - Choices: C1.b + C2.a + C3.a
  - Expected behavior: Returns ArrayList with one Utente
  - Return value: List with size == 1

F3: Retrieve all users with multiple users in database
  - Choices: C1.c + C2.a + C3.a
  - Expected behavior: Returns ArrayList with all Utente objects
  - Return value: List with size == number of users

F4: Database connection fails
  - Choices: C2.b
  - Expected behavior: SQLException is thrown

2.3.4. Suggested JUnit 5 test method names and structure

shouldReturnEmptyListWhenNoUsersExist()
  - Arrange: Clear utente table
  - Act: ArrayList<Utente> result = dao.getUtenti();
  - Assert:
    - assertNotNull(result)
    - assertEquals(0, result.size())

shouldReturnSingleUserWhenOneUserExists()
  - Arrange: Insert one test user
  - Act: ArrayList<Utente> result = dao.getUtenti();
  - Assert:
    - assertEquals(1, result.size())
    - assertNotNull(result.get(0).getEmail())

shouldReturnAllUsersWhenMultipleUsersExist()
  - Arrange: Insert 5 test users
  - Act: ArrayList<Utente> result = dao.getUtenti();
  - Assert:
    - assertEquals(5, result.size())

shouldThrowSQLExceptionWhenDatabaseConnectionFails()
  - Arrange: Mock ConPool to throw SQLException
  - Act & Assert: assertThrows(SQLException.class, () -> dao.getUtenti())

2.3.5. Parameterized test candidates

Good for testing different database states:

CSV schema:
Columns: numberOfUsers, expectedSize
Example rows:
  0, 0
  1, 1
  10, 10

--------------------------------------------------------------------------------
#### 2.4 Method: public int addUtente(Utente utente) throws SQLException
--------------------------------------------------------------------------------

2.4.1. Parameters and relevant state

Explicit parameters:
- utente: Utente (the user to add)

Relevant object state:
- Database connection availability
- Database state (utente table)

Preconditions:
- utente must not be null (enforced by IllegalArgumentException)
- utente must have required fields set (nome, cognome, email, telefono, password)
- Database connection must be available

Postconditions:
- If successful: User is inserted into database
- Returns number of rows affected (typically 1)
- If immagine is null: uses default value
- If immagine is not null: stores provided value
- Database connection is properly closed

2.4.2. Categories and choices

Category C1 - Utente parameter
  C1.a: utente == null (invalid)
  C1.b: utente != null && immagine is null
  C1.c: utente != null && immagine is not null

Category C2 - Database stateCategory C3 - Database connection
  C3.a: Connection is successfully obtained
  C3.b: Connection fails (SQLException)

Category C4 - SQL execution
  C4.a: INSERT executes successfully
  C4.b: INSERT fails (SQLException, e.g., duplicate email)

2.4.3. Test frames (combinations of choices)

F1: Add null user
  - Choices: C1.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message "L'utente non può essere null"

F2: Add valid user without image
  - Choices: C1.b + C3.a + C4.a
  - Expected behavior: User is inserted with default image
  - Return value: 1 (one row affected)
  - State: Uses query without image parameter

F3: Add valid user with image
  - Choices: C1.c + C3.a + C4.a
  - Expected behavior: User is inserted with provided image
  - Return value: 1
  - State: Uses query with image parameter

F4: Add user with duplicate email
  - Choices: C1.c + C3.a + C4.b
  - Expected behavior: SQLException (unique constraint violation)
  - Exception: SQLException

F5: Database connection fails
  - Choices: C1.b + C3.b
  - Expected behavior: SQLException is thrown

2.4.4. Suggested JUnit 5 test method names and structure

shouldThrowIllegalArgumentExceptionWhenUtenteIsNull()
  - Arrange: Utente utente = null;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.addUtente(utente))
    - assertEquals("L'utente non può essere null", ex.getMessage())

shouldInsertUserWithDefaultImageWhenImageIsNull()
  - Arrange:
    - Create Utente with all required fields
    - Set immagine = null
  - Act: int result = dao.addUtente(utente);
  - Assert:
    - assertEquals(1, result)
    - Verify user exists in database without custom image

shouldInsertUserWithImageWhenImageIsProvided()
  - Arrange:
    - Create Utente with all required fields
    - Set immagine = "user_profile.jpg"
  - Act: int result = dao.addUtente(utente);
  - Assert:
    - assertEquals(1, result)
    - Verify user exists with correct image

shouldThrowSQLExceptionWhenDuplicateEmailAdded()
  - Arrange:
    - Insert user with email "test@test.com"
    - Create new Utente with same email
  - Act & Assert: assertThrows(SQLException.class, () -> dao.addUtente(utente))

shouldThrowSQLExceptionWhenDatabaseConnectionFails()
  - Arrange: Mock ConPool to throw SQLException
  - Act & Assert: assertThrows(SQLException.class, 
      () -> dao.addUtente(validUtente))

2.4.5. Parameterized test candidates

Good for testing with/without image:

CSV schema:
Columns: imagePath, expectedResult, description
Example rows:
  null, 1, "default image"
  "profile.jpg", 1, "with image"

--------------------------------------------------------------------------------
#### 2.5 Method: public Utente getUserByEmailPassword(String email, String password) 
                 throws SQLException
--------------------------------------------------------------------------------

2.5.1. Parameters and relevant state

Explicit parameters:
- email: String (user's email)
- password: String (user's password, will be hashed with SHA1)

Relevant object state:
- Database connection availability
- Database state (utente table)

Preconditions:
- email must not be null (enforced by IllegalArgumentException)
- email must not be empty or whitespace-only (enforced by IllegalArgumentException)
- password must not be null (enforced by IllegalArgumentException)
- password must not be empty or whitespace-only (enforced by IllegalArgumentException)
- Database connection must be available

Postconditions:
- If credentials match: Returns fully populated Utente with ordini and recensioni
- If credentials don't match: Returns null
- Database connection is properly closed
- Password is hashed using SHA1 before comparison

2.5.2. Categories and choices

Category C1 - email parameter
  C1.a: email == null (invalid)
  C1.b: email is empty "" (invalid)
  C1.c: email is whitespace "   " (invalid)
  C1.d: email is valid && user exists && password matches
  C1.e: email is valid && user exists && password does NOT match
  C1.f: email is valid && user does NOT exist

Category C2 - password parameter
  C2.a: password == null (invalid)
  C2.b: password is empty "" (invalid)
  C2.c: password is whitespace "   " (invalid)
  C2.d: password is valid

Category C3 - Authentication result
  C3.a: Credentials match (user found)
  C3.b: Email exists but password wrong
  C3.c: Email does not exist

Category C4 - Database connection
  C4.a: Connection is successfully obtained
  C4.b: Connection fails (SQLException)

2.5.3. Test frames (combinations of choices)

F1: Login with null email
  - Choices: C1.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message 
    "L'email non può essere null o vuota"

F2: Login with empty email
  - Choices: C1.b
  - Expected behavior: IllegalArgumentException is thrown

F3: Login with whitespace email
  - Choices: C1.c
  - Expected behavior: IllegalArgumentException is thrown

F4: Login with null password
  - Choices: C1.d + C2.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message 
    "La password non può essere null o vuota"

F5: Login with empty password
  - Choices: C1.d + C2.b
  - Expected behavior: IllegalArgumentException is thrown

F6: Login with whitespace password
  - Choices: C1.d + C2.c
  - Expected behavior: IllegalArgumentException is thrown

F7: Login with valid credentials
  - Choices: C1.d + C2.d + C3.a + C4.a
  - Expected behavior: Returns fully populated Utente
  - Return value: Utente with all fields, ordini, and recensioni
  - State: Password was hashed with SHA1 for comparison

F8: Login with valid email but wrong password
  - Choices: C1.e + C2.d + C3.b + C4.a
  - Expected behavior: Returns null (authentication failed)
  - Return value: null

F9: Login with non-existing email
  - Choices: C1.f + C2.d + C3.c + C4.a
  - Expected behavior: Returns null
  - Return value: null

F10: Database connection fails
  - Choices: C1.d + C2.d + C4.b
  - Expected behavior: SQLException is thrown

2.5.4. Suggested JUnit 5 test method names and structure

shouldThrowIllegalArgumentExceptionWhenEmailIsNull()
  - Arrange: String email = null, password = "valid";
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.getUserByEmailPassword(email, password))
    - assertTrue(ex.getMessage().contains("email"))

shouldThrowIllegalArgumentExceptionWhenEmailIsEmpty()
  - Arrange: String email = "", password = "valid";
  - Act & Assert: assertThrows(IllegalArgumentException.class, 
      () -> dao.getUserByEmailPassword(email, password))

shouldThrowIllegalArgumentExceptionWhenPasswordIsNull()
  - Arrange: String email = "test@test.com", password = null;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.getUserByEmailPassword(email, password))
    - assertTrue(ex.getMessage().contains("password"))

shouldThrowIllegalArgumentExceptionWhenPasswordIsEmpty()
  - Arrange: String email = "test@test.com", password = "";
  - Act & Assert: assertThrows(IllegalArgumentException.class, 
      () -> dao.getUserByEmailPassword(email, password))

shouldReturnFullyPopulatedUserWhenValidCredentialsProvided()
  - Arrange:
    - Insert user with email "test@test.com" and password hash
    - Create orders and reviews for user
  - Act: Utente result = dao.getUserByEmailPassword("test@test.com", "password123");
  - Assert:
    - assertNotNull(result)
    - assertEquals("test@test.com", result.getEmail())
    - assertNotNull(result.getOrdini())
    - assertNotNull(result.getRecensioni())

shouldReturnNullWhenPasswordIsIncorrect()
  - Arrange: Insert user with email "test@test.com" and password "correct"
  - Act: Utente result = dao.getUserByEmailPassword("test@test.com", "wrong");
  - Assert: assertNull(result)

shouldReturnNullWhenEmailDoesNotExist()
  - Arrange: Ensure email "nonexistent@test.com" does not exist
  - Act: Utente result = dao.getUserByEmailPassword("nonexistent@test.com", "password");
  - Assert: assertNull(result)

shouldThrowSQLExceptionWhenDatabaseConnectionFails()
  - Arrange: Mock ConPool to throw SQLException
  - Act & Assert: assertThrows(SQLException.class, 
      () -> dao.getUserByEmailPassword("test@test.com", "password"))

2.5.5. Parameterized test candidates

Excellent for testing various invalid inputs:

CSV schema:
Columns: email, password, description
Example rows:
  null, "valid", "null email"
  "", "valid", "empty email"
  "   ", "valid", "whitespace email"
  "valid@test.com", null, "null password"
  "valid@test.com", "", "empty password"
  "valid@test.com", "   ", "whitespace password"

--------------------------------------------------------------------------------
#### 2.6 Method: public static boolean isEmailPresent(String email) 
                 throws SQLException
--------------------------------------------------------------------------------

2.6.1. Parameters and relevant state

Explicit parameters:
- email: String (email to check)

Preconditions:
- email must not be null (enforced by IllegalArgumentException)
- email must not be empty or whitespace-only (enforced by IllegalArgumentException)

Postconditions:
- Returns true if email exists in database
- Returns false if email does not exist
- Database connection is properly closed

2.6.2. Categories and choices

Category C1 - email parameter
  C1.a: email == null (invalid)
  C1.b: email is empty "" (invalid)
  C1.c: email is whitespace "   " (invalid)
  C1.d: email is valid && exists in database
  C1.e: email is valid && does NOT exist in database

Category C2 - Database state
  C2.a: Email exists
  C2.b: Email does not exist

Category C3 - Database connection
  C3.a: Connection is successfully obtained
  C3.b: Connection fails (SQLException)

2.6.3. Test frames (combinations of choices)

F1: Check with null email
  - Choices: C1.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message 
    "L'email non può essere null o vuota"

F2: Check with empty email
  - Choices: C1.b
  - Expected behavior: IllegalArgumentException is thrown

F3: Check with whitespace email
  - Choices: C1.c
  - Expected behavior: IllegalArgumentException is thrown

F4: Check existing email
  - Choices: C1.d + C2.a + C3.a
  - Expected behavior: Returns true
  - Return value: true

F5: Check non-existing email
  - Choices: C1.e + C2.b + C3.a
  - Expected behavior: Returns false
  - Return value: false

F6: Database connection fails
  - Choices: C1.d + C3.b
  - Expected behavior: SQLException is thrown

2.6.4. Suggested JUnit 5 test method names and structure

shouldThrowIllegalArgumentExceptionWhenEmailIsNull()
  - Arrange: String email = null;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> UtenteDAO.isEmailPresent(email))
    - assertTrue(ex.getMessage().contains("email"))

shouldThrowIllegalArgumentExceptionWhenEmailIsEmpty()
  - Arrange: String email = "";
  - Act & Assert: assertThrows(IllegalArgumentException.class, 
      () -> UtenteDAO.isEmailPresent(email))

shouldReturnTrueWhenEmailExists()
  - Arrange: Insert user with email "test@test.com"
  - Act: boolean result = UtenteDAO.isEmailPresent("test@test.com");
  - Assert: assertTrue(result)

shouldReturnFalseWhenEmailDoesNotExist()
  - Arrange: Ensure email "nonexistent@test.com" does not exist
  - Act: boolean result = UtenteDAO.isEmailPresent("nonexistent@test.com");
  - Assert: assertFalse(result)

shouldThrowSQLExceptionWhenDatabaseConnectionFails()
  - Arrange: Mock ConPool to throw SQLException
  - Act & Assert: assertThrows(SQLException.class, 
      () -> UtenteDAO.isEmailPresent("test@test.com"))

2.6.5. Parameterized test candidates

Good for testing various invalid emails:

CSV schema:
Columns: invalidEmail, description
Example rows:
  null, "null email"
  "", "empty email"
  "   ", "whitespace email"
  "\t", "tab character"

--------------------------------------------------------------------------------
#### 2.7 Method: public void editProfilo(String operation, String modifica, 
                 int idProfilo) throws SQLException
--------------------------------------------------------------------------------

2.7.1. Parameters and relevant state

Explicit parameters:
- operation: String (the type of edit: "/editNome", "/editCognome", etc.)
- modifica: String (the new value)
- idProfilo: int (the user ID to update)

Relevant object state:
- Database connection availability
- Database state (utente table)

Preconditions:
- operation must not be null (enforced by IllegalArgumentException)
- operation must not be empty or whitespace-only (enforced by IllegalArgumentException)
- modifica must not be null (enforced by IllegalArgumentException)
- modifica must not be empty or whitespace-only (enforced by IllegalArgumentException)
- idProfilo must be > 0 (enforced by IllegalArgumentException)
- Database connection must be available

Postconditions:
- If successful: User profile field is updated
- Method returns void
- Database connection is properly closed
- Different SQL executed based on operation value

2.7.2. Categories and choices

Category C1 - operation parameter
  C1.a: operation == null (invalid)
  C1.b: operation is empty "" (invalid)
  C1.c: operation is whitespace "   " (invalid)
  C1.d: operation == "/editNome"
  C1.e: operation == "/editCognome"
  C1.f: operation == "/editEmail"
  C1.g: operation == "/editTelefono"
  C1.h: operation == "/editImmagine"
  C1.i: operation is unrecognized value (no matching if/else)

Category C2 - modifica parameter
  C2.a: modifica == null (invalid)
  C2.b: modifica is empty "" (invalid)
  C2.c: modifica is whitespace "   " (invalid)
  C2.d: modifica is valid non-empty string

Category C3 - idProfilo parameter
  C3.a: idProfilo <= 0 (invalid)
  C3.b: idProfilo > 0 && user exists
  C3.c: idProfilo > 0 && user does NOT exist

Category C4 - Database connection
  C4.a: Connection is successfully obtained
  C4.b: Connection fails (SQLException)

2.7.3. Test frames (combinations of choices)

F1: Edit with null operation
  - Choices: C1.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message 
    "L'operazione non può essere null o vuota"

F2: Edit with empty operation
  - Choices: C1.b
  - Expected behavior: IllegalArgumentException is thrown

F3: Edit with null modifica
  - Choices: C1.d + C2.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message 
    "La modifica non può essere null o vuota"

F4: Edit with invalid idProfilo
  - Choices: C1.d + C2.d + C3.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message 
    "L'ID del profilo deve essere maggiore di zero"

F5: Edit nome successfully
  - Choices: C1.d + C2.d + C3.b + C4.a
  - Expected behavior: User's nome is updated
  - Return value: void (no exception)
  - State: Database record updated

F6: Edit cognome successfully
  - Choices: C1.e + C2.d + C3.b + C4.a
  - Expected behavior: User's cognome is updated

F7: Edit email successfully
  - Choices: C1.f + C2.d + C3.b + C4.a
  - Expected behavior: User's email is updated

F8: Edit telefono successfully
  - Choices: C1.g + C2.d + C3.b + C4.a
  - Expected behavior: User's telefono is updated

F9: Edit immagine successfully
  - Choices: C1.h + C2.d + C3.b + C4.a
  - Expected behavior: User's immagine is updated

F10: Edit with unrecognized operation
  - Choices: C1.i + C2.d + C3.b + C4.a
  - Expected behavior: No update occurs (no matching if/else branch)
  - Return value: void (silent failure)
  - Note: Potential bug - should validate operation

F11: Edit non-existing user
  - Choices: C1.d + C2.d + C3.c + C4.a
  - Expected behavior: No error (0 rows updated)
  - Return value: void

F12: Database connection fails
  - Choices: C1.d + C2.d + C3.b + C4.b
  - Expected behavior: SQLException is thrown

2.7.4. Suggested JUnit 5 test method names and structure

shouldThrowIllegalArgumentExceptionWhenOperationIsNull()
  - Arrange: String operation = null;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.editProfilo(operation, "NewValue", 1))
    - assertTrue(ex.getMessage().contains("operazione"))

shouldThrowIllegalArgumentExceptionWhenModificaIsNull()
  - Arrange: String modifica = null;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.editProfilo("/editNome", modifica, 1))
    - assertTrue(ex.getMessage().contains("modifica"))

shouldThrowIllegalArgumentExceptionWhenIdProfiloIsZero()
  - Arrange: int idProfilo = 0;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.editProfilo("/editNome", "NewName", idProfilo))
    - assertTrue(ex.getMessage().contains("profilo"))

shouldUpdateNomeWhenEditNomeOperationProvided()
  - Arrange:
    - Insert user with ID 100, nome "OldName"
  - Act: dao.editProfilo("/editNome", "NewName", 100);
  - Assert:
    - assertDoesNotThrow
    - Verify user's nome is "NewName" in database

shouldUpdateCognomeWhenEditCognomeOperationProvided()
  - Arrange: Insert user with ID 100
  - Act: dao.editProfilo("/editCognome", "NewSurname", 100);
  - Assert: Verify cognome updated

shouldUpdateEmailWhenEditEmailOperationProvided()
  - Arrange: Insert user with ID 100
  - Act: dao.editProfilo("/editEmail", "newemail@test.com", 100);
  - Assert: Verify email updated

shouldUpdateTelefonoWhenEditTelefonoOperationProvided()
  - Arrange: Insert user with ID 100
  - Act: dao.editProfilo("/editTelefono", "1234567890", 100);
  - Assert: Verify telefono updated

shouldUpdateImmagineWhenEditImmagineOperationProvided()
  - Arrange: Insert user with ID 100
  - Act: dao.editProfilo("/editImmagine", "newprofile.jpg", 100);
  - Assert: Verify immagine updated

shouldCompleteWithoutErrorWhenUnrecognizedOperation()
  - Arrange: Insert user with ID 100
  - Act: dao.editProfilo("/editInvalidField", "value", 100);
  - Assert:
    - assertDoesNotThrow
    - Verify no fields were updated (potential bug test)

shouldCompleteWithoutErrorWhenUserDoesNotExist()
  - Arrange: Ensure user with ID 99999 does not exist
  - Act: dao.editProfilo("/editNome", "NewName", 99999);
  - Assert: assertDoesNotThrow

shouldThrowSQLExceptionWhenDatabaseConnectionFails()
  - Arrange: Mock ConPool to throw SQLException
  - Act & Assert: assertThrows(SQLException.class, 
      () -> dao.editProfilo("/editNome", "NewName", 1))

2.7.5. Parameterized test candidates

Excellent candidate for testing all operations:

CSV schema:
Columns: operation, fieldName, testValue, description
Example rows:
  "/editNome", "nome", "John", "edit first name"
  "/editCognome", "cognome", "Doe", "edit last name"
  "/editEmail", "email", "new@test.com", "edit email"
  "/editTelefono", "telefono", "1234567890", "edit phone"
  "/editImmagine", "immagine", "profile.jpg", "edit image"

Also good for testing invalid inputs:

CSV schema:
Columns: operation, modifica, idProfilo, description
Example rows:
  null, "value", 1, "null operation"
  "", "value", 1, "empty operation"
  "/editNome", null, 1, "null modifica"
  "/editNome", "", 1, "empty modifica"
  "/editNome", "value", 0, "zero ID"
  "/editNome", "value", -1, "negative ID"

================================================================================
### 3. OVERALL TESTING STRATEGY
================================================================================

Integration Testing Considerations:
- Requires database with utente, ordine, recensione tables
- Password hashing with SHA1 must be considered
- Depends on OrdineDAO and RecensioneDAO for user relationships
- Use in-memory database or test database
- Set up referential integrity

Test Data Setup:
- Create test users with various states
- Hash passwords correctly for authentication tests
- Create associated orders and reviews
- Use @BeforeEach for clean state
- Use transactions for isolation

Special Testing Challenges:
- getUserByEmailPassword uses SHA1 hashing (must match database implementation)
- editProfilo has multiple branches based on operation string
- editProfilo silently ignores unrecognized operations (potential bug)
- addUtente has two different INSERT statements based on image presence
- isEmailPresent is static method (testing consideration)
- Multiple methods call other DAOs (coupling)

Coverage Goals:
- All 6 public methods tested (plus 1 static method)
- All exception paths verified
- All editProfilo operation branches tested
- Password hashing verified
- Email validation tested
- All parameter validation tested
- Complex authentication logic verified

Mock/Stub Strategy:
- Mock ConPool for connection failures
- Consider mocking OrdineDAO and RecensioneDAO for unit testing
- Use real database for integration tests
- Mock SHA1 hashing for unit tests if needed

Security Considerations:
- Password is stored as SHA1 hash (note: SHA1 is deprecated, should use bcrypt/Argon2)
- Test that plain passwords are never stored
- Verify hashing occurs before database query

Performance Considerations:
- getUserByEmailPassword and getUtenteById make multiple DAO calls
- Consider caching strategies for user data

Bug/Design Notes:
- editProfilo does not validate operation parameter against allowed values
- Could throw exception for unrecognized operations instead of silent failure
- Multiple if-else chains in editProfilo could be refactored to switch or strategy pattern

================================================================================
END OF REPORT
================================================================================
