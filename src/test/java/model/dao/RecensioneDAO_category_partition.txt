================================================================================
CATEGORY-PARTITION TESTING REPORT
Class: RecensioneDAO
Package: model.dao
================================================================================

### 1. CLASS OVERVIEW

Class name: RecensioneDAO
Package: model.dao

Role in the domain:
The RecensioneDAO class is a Data Access Object responsible for managing database 
operations related to the Recensione (Review) entity. It provides operations to 
retrieve reviews by user or product, add new reviews, and delete reviews. It 
handles complex JOIN queries to fetch related user and product information.

Important fields:
- No instance fields (stateless DAO).
- Relies on ConPool for database connections.
- Manages recensione table with relationships to utente and prodotto tables.

Invariants:
- Database connection must be properly managed.
- All database operations must handle SQLException appropriately.
- Parameter validation occurs before database operations.
- null parameters are rejected with IllegalArgumentException.
- ID parameters must be positive (> 0).
- Reviews have associated users and products.

================================================================================
### 2. METHODS TO BE TESTED
================================================================================

--------------------------------------------------------------------------------
#### 2.1 Constructor: RecensioneDAO()
--------------------------------------------------------------------------------

2.1.1. Parameters and relevant state

Explicit parameters:
- None

Postconditions:
- A new RecensioneDAO instance is created

2.1.2. Categories and choices

Category C1 - Constructor invocation
  C1.a: Constructor is called successfully

2.1.3. Test frames

F1: Create new RecensioneDAO instance
  - Expected behavior: New instance created without exceptions

2.1.4. Suggested JUnit 5 test method names

shouldCreateNewRecensioneDAOInstanceWhenConstructorCalled()
  - Arrange: None
  - Act: RecensioneDAO dao = new RecensioneDAO();
  - Assert: assertNotNull(dao)

2.1.5. Parameterized test candidates
- Not applicable

--------------------------------------------------------------------------------
#### 2.2 Method: public ArrayList<Recensione> getRecensioniByUtente(Utente utente) 
                 throws SQLException
--------------------------------------------------------------------------------

2.2.1. Parameters and relevant state

Explicit parameters:
- utente: Utente (the user whose reviews to retrieve)

Relevant object state:
- Database connection availability
- Database state (recensione, utente, prodotto tables)

Preconditions:
- utente must not be null (enforced by IllegalArgumentException)
- utente.getId() must return valid ID
- Database connection must be available

Postconditions:
- Returns ArrayList<Recensione> containing all reviews by the user
- Each Recensione is fully populated with Utente and Prodotto details
- Empty list if user has no reviews
- Database connection is properly closed

2.2.2. Categories and choices

Category C1 - Utente parameter
  C1.a: utente == null (invalid)
  C1.b: utente != null && has reviews
  C1.c: utente != null && has NO reviews

Category C2 - Database state (recensione table)
  C2.a: User has no reviews
  C2.b: User has one review
  C2.c: User has multiple reviews

Category C3 - Database connection
  C3.a: Connection is successfully obtained
  C3.b: Connection fails (SQLException)

Category C4 - SQL execution (complex JOIN)
  C4.a: JOIN query executes successfully
  C4.b: JOIN query fails (SQLException)

2.2.3. Test frames (combinations of choices)

F1: Get reviews for null user
  - Choices: C1.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message "L'utente non può essere null"

F2: Get reviews for user with no reviews
  - Choices: C1.c + C2.a + C3.a + C4.a
  - Expected behavior: Returns empty ArrayList
  - Return value: Non-null, empty list (size == 0)

F3: Get reviews for user with one review
  - Choices: C1.b + C2.b + C3.a + C4.a
  - Expected behavior: Returns ArrayList with one fully populated Recensione
  - Return value: List with size == 1
  - State: Recensione has all fields set including Utente and Prodotto details

F4: Get reviews for user with multiple reviews
  - Choices: C1.b + C2.c + C3.a + C4.a
  - Expected behavior: Returns ArrayList with all reviews
  - Return value: List with size > 1
  - State: All Recensione objects fully populated

F5: Database connection fails
  - Choices: C1.b + C3.b
  - Expected behavior: SQLException is thrown
  - Exception: SQLException

F6: JOIN query fails
  - Choices: C1.b + C3.a + C4.b
  - Expected behavior: SQLException is thrown
  - Exception: SQLException

2.2.4. Suggested JUnit 5 test method names and structure

shouldThrowIllegalArgumentExceptionWhenUtenteIsNull()
  - Arrange: Utente utente = null;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.getRecensioniByUtente(utente))
    - assertEquals("L'utente non può essere null", ex.getMessage())

shouldReturnEmptyListWhenUserHasNoReviews()
  - Arrange:
    - Create user with ID 100
    - Ensure no reviews for this user
  - Act: ArrayList<Recensione> result = dao.getRecensioniByUtente(utente);
  - Assert:
    - assertNotNull(result)
    - assertEquals(0, result.size())

shouldReturnSingleReviewWhenUserHasOneReview()
  - Arrange:
    - Create user, product, and one review
    - User ID 100, Product ID 50
  - Act: ArrayList<Recensione> result = dao.getRecensioniByUtente(utente);
  - Assert:
    - assertEquals(1, result.size())
    - Recensione r = result.get(0);
    - assertNotNull(r.getUtente())
    - assertEquals(100, r.getUtente().getId())
    - assertNotNull(r.getProdotto())
    - assertEquals(50, r.getProdotto().getId())
    - Verify all Recensione fields populated

shouldReturnAllReviewsWhenUserHasMultipleReviews()
  - Arrange:
    - Create user with 3 reviews
  - Act: ArrayList<Recensione> result = dao.getRecensioniByUtente(utente);
  - Assert:
    - assertEquals(3, result.size())
    - Verify all reviews fully populated

shouldThrowSQLExceptionWhenDatabaseConnectionFails()
  - Arrange: Mock ConPool to throw SQLException
  - Act & Assert: assertThrows(SQLException.class, 
      () -> dao.getRecensioniByUtente(utente))

2.2.5. Parameterized test candidates

Good candidate for testing different numbers of reviews:

CSV schema:
Columns: userId, numberOfReviews, expectedSize
Example rows:
  100, 0, 0
  101, 1, 1
  102, 5, 5

--------------------------------------------------------------------------------
#### 2.3 Method: public ArrayList<Recensione> getRecensioniByProdotto(Prodotto prodotto) 
                 throws SQLException
--------------------------------------------------------------------------------

2.3.1. Parameters and relevant state

Explicit parameters:
- prodotto: Prodotto (the product whose reviews to retrieve)

Relevant object state:
- Database connection availability
- Database state (recensione, utente, prodotto tables)

Preconditions:
- prodotto must not be null (enforced by IllegalArgumentException)
- prodotto.getId() must return valid ID
- Database connection must be available

Postconditions:
- Returns ArrayList<Recensione> containing all reviews for the product
- Each Recensione is fully populated with Utente and Prodotto details
- Empty list if product has no reviews
- Database connection is properly closed

2.3.2. Categories and choices

Category C1 - Prodotto parameter
  C1.a: prodotto == null (invalid)
  C1.b: prodotto != null && has reviews
  C1.c: prodotto != null && has NO reviews

Category C2 - Database state (recensione table)
  C2.a: Product has no reviews
  C2.b: Product has one review
  C2.c: Product has multiple reviews

Category C3 - Database connection
  C3.a: Connection is successfully obtained
  C3.b: Connection fails (SQLException)

Category C4 - SQL execution (complex JOIN)
  C4.a: JOIN query executes successfully
  C4.b: JOIN query fails (SQLException)

2.3.3. Test frames (combinations of choices)

F1: Get reviews for null product
  - Choices: C1.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message "Il prodotto non può essere null"

F2: Get reviews for product with no reviews
  - Choices: C1.c + C2.a + C3.a + C4.a
  - Expected behavior: Returns empty ArrayList
  - Return value: Non-null, empty list (size == 0)

F3: Get reviews for product with one review
  - Choices: C1.b + C2.b + C3.a + C4.a
  - Expected behavior: Returns ArrayList with one Recensione
  - Return value: List with size == 1
  - State: Recensione fully populated

F4: Get reviews for product with multiple reviews
  - Choices: C1.b + C2.c + C3.a + C4.a
  - Expected behavior: Returns ArrayList with all reviews
  - Return value: List with size > 1
  - State: All reviews from different users

F5: Database connection fails
  - Choices: C1.b + C3.b
  - Expected behavior: SQLException is thrown
  - Exception: SQLException

F6: JOIN query fails
  - Choices: C1.b + C3.a + C4.b
  - Expected behavior: SQLException is thrown
  - Exception: SQLException

2.3.4. Suggested JUnit 5 test method names and structure

shouldThrowIllegalArgumentExceptionWhenProdottoIsNull()
  - Arrange: Prodotto prodotto = null;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.getRecensioniByProdotto(prodotto))
    - assertEquals("Il prodotto non può essere null", ex.getMessage())

shouldReturnEmptyListWhenProductHasNoReviews()
  - Arrange:
    - Create product with ID 50
    - Ensure no reviews for this product
  - Act: ArrayList<Recensione> result = dao.getRecensioniByProdotto(prodotto);
  - Assert:
    - assertNotNull(result)
    - assertEquals(0, result.size())

shouldReturnSingleReviewWhenProductHasOneReview()
  - Arrange:
    - Create product with ID 50
    - Create one review for product
  - Act: ArrayList<Recensione> result = dao.getRecensioniByProdotto(prodotto);
  - Assert:
    - assertEquals(1, result.size())
    - assertNotNull(result.get(0).getProdotto())
    - assertEquals(50, result.get(0).getProdotto().getId())

shouldReturnAllReviewsWhenProductHasMultipleReviews()
  - Arrange:
    - Create product with 3 reviews from different users
  - Act: ArrayList<Recensione> result = dao.getRecensioniByProdotto(prodotto);
  - Assert:
    - assertEquals(3, result.size())

shouldThrowSQLExceptionWhenDatabaseConnectionFails()
  - Arrange: Mock ConPool to throw SQLException
  - Act & Assert: assertThrows(SQLException.class, 
      () -> dao.getRecensioniByProdotto(prodotto))

2.3.5. Parameterized test candidates

Good candidate for testing different numbers of reviews:

CSV schema:
Columns: productId, numberOfReviews, expectedSize
Example rows:
  50, 0, 0
  51, 1, 1
  52, 10, 10

--------------------------------------------------------------------------------
#### 2.4 Method: public int addRecensione(Recensione recensione) throws SQLException
--------------------------------------------------------------------------------

2.4.1. Parameters and relevant state

Explicit parameters:
- recensione: Recensione (the review to add)

Relevant object state:
- Database connection availability
- Database state (recensione table)

Preconditions:
- recensione must not be null (enforced by IllegalArgumentException)
- recensione.getUtente() must not be null
- recensione.getProdotto() must not be null
- recensione.getUtente().getId() must be valid
- recensione.getProdotto().getId() must be valid
- Database connection must be available

Postconditions:
- If successful: Review is inserted into recensione table
- Returns number of rows affected (typically 1)
- Database connection is properly closed

2.4.2. Categories and choices

Category C1 - Recensione parameter
  C1.a: recensione == null (invalid)
  C1.b: recensione != null && fully valid
  C1.c: recensione != null BUT utente is null (NullPointerException risk)
  C1.d: recensione != null BUT prodotto is null (NullPointerException risk)

Category C2 - Review data
  C2.a: Valid testo and valutazione
  C2.b: testo is null or empty
  C2.c: valutazione is out of range (< 1 or > 5, assuming 1-5 scale)

Category C3 - Database connection
  C3.a: Connection is successfully obtained
  C3.b: Connection fails (SQLException)

Category C4 - SQL execution
  C4.a: INSERT executes successfully
  C4.b: INSERT fails (SQLException, e.g., FK violation)

2.4.3. Test frames (combinations of choices)

F1: Add null review
  - Choices: C1.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message "La recensione non può essere null"

F2: Add valid review
  - Choices: C1.b + C2.a + C3.a + C4.a
  - Expected behavior: Review is inserted successfully
  - Return value: 1 (one row affected)
  - State: Database contains new review

F3: Add review with null utente
  - Choices: C1.c + C3.a
  - Expected behavior: NullPointerException when accessing utente.getId()
  - Exception: NullPointerException

F4: Add review with null prodotto
  - Choices: C1.d + C3.a
  - Expected behavior: NullPointerException when accessing prodotto.getId()
  - Exception: NullPointerException

F5: Add review with invalid foreign key
  - Choices: C1.b + C3.a + C4.b
  - Expected behavior: SQLException (FK constraint violation)
  - Exception: SQLException

F6: Database connection fails
  - Choices: C1.b + C3.b
  - Expected behavior: SQLException is thrown
  - Exception: SQLException

2.4.4. Suggested JUnit 5 test method names and structure

shouldThrowIllegalArgumentExceptionWhenRecensioneIsNull()
  - Arrange: Recensione recensione = null;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.addRecensione(recensione))
    - assertEquals("La recensione non può essere null", ex.getMessage())

shouldInsertRecensioneAndReturnOneWhenValidRecensioneProvided()
  - Arrange:
    - Create valid Utente and Prodotto
    - Create Recensione with all required fields
    - recensione.setTesto("Great product!")
    - recensione.setValutazione(5)
  - Act: int result = dao.addRecensione(recensione);
  - Assert:
    - assertEquals(1, result)
    - Verify review exists in database

shouldThrowNullPointerExceptionWhenUtenteIsNull()
  - Arrange:
    - Create Recensione with utente = null
    - Set valid prodotto
  - Act & Assert: assertThrows(NullPointerException.class, 
      () -> dao.addRecensione(recensione))

shouldThrowNullPointerExceptionWhenProdottoIsNull()
  - Arrange:
    - Create Recensione with valid utente
    - Set prodotto = null
  - Act & Assert: assertThrows(NullPointerException.class, 
      () -> dao.addRecensione(recensione))

shouldThrowSQLExceptionWhenForeignKeyViolated()
  - Arrange:
    - Create Recensione with non-existing user ID
  - Act & Assert: assertThrows(SQLException.class, 
      () -> dao.addRecensione(recensione))

shouldThrowSQLExceptionWhenDatabaseConnectionFails()
  - Arrange: Mock ConPool to throw SQLException
  - Act & Assert: assertThrows(SQLException.class, 
      () -> dao.addRecensione(validRecensione))

2.4.5. Parameterized test candidates

Good candidate for testing various valid reviews:

CSV schema:
Columns: userId, productId, valutazione, testo, expectedResult
Example rows:
  1, 10, 5, "Excellent!", 1
  2, 20, 3, "Average", 1
  3, 30, 1, "Poor quality", 1

--------------------------------------------------------------------------------
#### 2.5 Method: public void deleteRecensione(int id_recensione) throws SQLException
--------------------------------------------------------------------------------

2.5.1. Parameters and relevant state

Explicit parameters:
- id_recensione: int (the review ID to delete)

Relevant object state:
- Database connection availability
- Database state (recensione table)

Preconditions:
- id_recensione must be > 0 (enforced by IllegalArgumentException)
- Database connection must be available

Postconditions:
- If successful: Review with given ID is deleted from database
- Method returns void
- Database connection is properly closed

2.5.2. Categories and choices

Category C1 - id_recensione parameter
  C1.a: id_recensione <= 0 (invalid: zero)
  C1.b: id_recensione < 0 (invalid: negative)
  C1.c: id_recensione > 0 && review exists
  C1.d: id_recensione > 0 && review does NOT exist

Category C2 - Database state
  C2.a: Review with ID exists
  C2.b: Review with ID does not exist

Category C3 - Database connection
  C3.a: Connection is successfully obtained
  C3.b: Connection fails (SQLException)

Category C4 - SQL execution
  C4.a: DELETE executes successfully (0 or 1 rows affected)
  C4.b: DELETE fails (SQLException)

2.5.3. Test frames (combinations of choices)

F1: Delete with zero ID
  - Choices: C1.a
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException with message 
    "L'ID della recensione deve essere maggiore di zero"

F2: Delete with negative ID
  - Choices: C1.b
  - Expected behavior: IllegalArgumentException is thrown
  - Exception: IllegalArgumentException

F3: Delete existing review
  - Choices: C1.c + C2.a + C3.a + C4.a
  - Expected behavior: Review is deleted
  - Return value: void (no exception)
  - State: Review no longer exists in database

F4: Delete non-existing review
  - Choices: C1.d + C2.b + C3.a + C4.a
  - Expected behavior: No error (silent, 0 rows affected)
  - Return value: void
  - State: Database unchanged

F5: Database connection fails
  - Choices: C1.c + C3.b
  - Expected behavior: SQLException is thrown
  - Exception: SQLException

F6: DELETE fails
  - Choices: C1.c + C3.a + C4.b
  - Expected behavior: SQLException is thrown
  - Exception: SQLException

2.5.4. Suggested JUnit 5 test method names and structure

shouldThrowIllegalArgumentExceptionWhenIdIsZero()
  - Arrange: int id_recensione = 0;
  - Act & Assert:
    - IllegalArgumentException ex = assertThrows(IllegalArgumentException.class,
        () -> dao.deleteRecensione(id_recensione))
    - assertTrue(ex.getMessage().contains("maggiore di zero"))

shouldThrowIllegalArgumentExceptionWhenIdIsNegative()
  - Arrange: int id_recensione = -10;
  - Act & Assert: assertThrows(IllegalArgumentException.class, 
      () -> dao.deleteRecensione(id_recensione))

shouldDeleteReviewWhenValidIdProvided()
  - Arrange:
    - Insert test review with ID 100
    - Verify it exists
  - Act: dao.deleteRecensione(100);
  - Assert:
    - assertDoesNotThrow
    - Verify review no longer exists

shouldCompleteWithoutErrorWhenReviewDoesNotExist()
  - Arrange: Ensure review with ID 99999 does not exist
  - Act: dao.deleteRecensione(99999);
  - Assert: assertDoesNotThrow

shouldThrowSQLExceptionWhenDatabaseConnectionFails()
  - Arrange: Mock ConPool to throw SQLException
  - Act & Assert: assertThrows(SQLException.class, 
      () -> dao.deleteRecensione(1))

2.5.5. Parameterized test candidates

Good candidate for testing invalid IDs:

CSV schema:
Columns: invalidId, description
Example rows:
  0, "zero ID"
  -1, "negative ID"
  -100, "large negative ID"

================================================================================
### 3. OVERALL TESTING STRATEGY
================================================================================

Integration Testing Considerations:
- Requires database with recensione, utente, prodotto tables
- Complex JOIN queries spanning 3 tables
- Foreign key relationships must be maintained
- Use in-memory database or test database

Test Data Setup:
- Create test users and products first
- Create test reviews linking users to products
- Use @BeforeEach to establish clean state
- Use transactions for test isolation

Special Testing Challenges:
- Both retrieval methods use complex JOINs across 3 tables
- Need to populate many fields in returned objects
- addRecensione uses System.out.println (testing concern)
- Need to handle NULL values gracefully

Coverage Goals:
- All public methods tested
- All exception paths verified
- Boundary conditions (no reviews, multiple reviews)
- All parameter validation tested
- Complex JOIN queries verified

Mock/Stub Strategy:
- Mock ConPool for connection failure tests
- Use real database for integration tests
- Verify proper population of nested objects

================================================================================
END OF REPORT
================================================================================
