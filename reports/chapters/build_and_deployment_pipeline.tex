\chapter{Build and Deployment Pipeline}

\section*{Context: Security in CI/CD}

\textbf{Build and deployment pipeline}

To automate all testing, deployment and build operations a github action has been set up that is executed at every push.

\section*{Overview}

Our ‘main.yml’ pipeline ensures that every change is ready and safe for production.

\begin{itemize}
    \item \textbf{trigger}: The workflow activates at every push on the main branch (main)
    \item \textbf{environment}: The entire workflow runs on a virtual machine based on ‘ubuntu-latest’
\end{itemize}

\textbf{flow:}

In our pipeline multiple steps are executed, in order:
\begin{itemize}
    \item Code checkout
    \item Security scan with GitGuardian
    \item Dependency vulnerability analysis with Snyk
    \item Java 19 environment setup and dependency caching
    \item MySQL database initialization with data import
    \item Build, unit tests and mutation coverage, static analysis with SonarQube
    \item Upload of coverage results to Codecov
    \item Login to Docker Hub, image build and push
\end{itemize}

\section*{Steps in detail}

In this paragraph we analyze some fundamental steps of our github action.

\textbf{Security scan with GitGuardian:}

thanks to sending the current commit data to GitGuardian we initialize a code scan on the latest changes.
This will allow verifying the presence of exposed passwords or secrets, blocking pipeline execution in case vulnerabilities are identified.

\vspace{0.3cm}

\textbf{Dependency vulnerability analysis with Snyk:}

thanks to the use of the tool 'snyk' we identify security weaknesses classified according to CWE through dependency analysis.

\vspace{0.3cm}

\textbf{Mysql:}

inside the github action a test database with test data is instantiated. This is necessary because otherwise most tests would fail due to missing connection to the db.
This solution allows running tests on a totally isolated, reproducible and modifiable environment.

\vspace{0.3cm}

\textbf{Build, Unit Testing and Mutation Testing:}

Through the command ‘mvn -B clean verify -P pitest’ we are able to build, launch unit tests and mutation tests on our application.
Through the maven profile ‘pitest’ mutants are introduced in packages model.beans, model.dao and services.

The test results are subsequently uploaded to the ‘Codecov’ platform which will allow us to visualize results and will manage the failure or success of the push thanks to the key ‘\verb|fail_ci_if_error|: true’.
Furthermore a static code analysis is performed via 'SonarQube' with the flag '\verb|-Dsonar.qualitygate.wait|=true' which allows blocking the pipeline in case of quality weaknesses.

\vspace{0.3cm}

\textbf{Additional security:}

Inside our github action we will not find credentials but references to secrets saved in the github repo, such as for example

\begin{verbatim}
- name: Log in to Docker Hub
     uses: docker/login-action@v3
     with:
       username: ${{ secrets.DOCKER_USERNAME }}
       password: ${{ secrets.DOCKER_PASSWORD }}
\end{verbatim}

\textbf{Docker hub:}

Finally if all the the steps of the pipeline have been executed successfully the build and push of the docker image on docker hub is performed.