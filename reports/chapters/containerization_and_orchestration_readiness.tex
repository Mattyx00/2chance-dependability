\chapter{Containerization and Orchestration Readiness}

\section*{Context: Docker \& DockerHub}

A containerization strategy has been prepared for our project to distribute the project more easily, ensuring portability, dependency isolation, and consistency between development environments.

\section*{Containerization Strategy}

A Dockerfile was created that builds our application in multiple steps:

\begin{itemize}
    \item \textbf{War file build}: through the command \texttt{mvn clean package -Dmaven.test.skip=true}, the war file is created on a \texttt{maven:3.9-eclipse-temurin-19} image
    \item \textbf{Application}: Copying of the war file inside the \texttt{tomcat:9.0} image
    \item \textbf{Network}: port 8080 is exposed to access the application
\end{itemize}

\section*{Docker compose}

Since our architecture includes a database that is currently not hosted online, it was necessary to create a docker compose that initializes both the application image created previously and the database.

We will therefore have two services:
\begin{itemize}
    \item \textbf{webapp}: the application created previously
    \item \textbf{mysql-db}: the mysql database which is initialized on a \texttt{mysql:8.0} image. Furthermore, the db is initialized with data from the dump \texttt{db\_import.sql}
\end{itemize}

\section*{CI/CD}

Containerization is central to our automation pipeline managed with GitHub Actions.
In fact, upon every push, a github action will be executed that will rebuild the image and execute all tests and necessary operations on the running docker image.

Indeed, the last operation of our action is the push of our image to docker hub via the following step:

\begin{verbatim}
- name: Build and push Docker image
     uses: docker/build-push-action@v5
     with:
       context: .
       push: true
       tags: ${{ secrets.DOCKER_USERNAME }}/2chance-dependability:latest
\end{verbatim}