\chapter{Garanzia di Sicurezza e Valutazione delle Vulnerabilità}
\label{ch:security-assurance}

\section{Contesto e Obiettivi}
In un progetto orientato alla dependabilità, la garanzia di sicurezza è trattata come parte dell'affidabilità operativa: difetti che espongono segreti, introducono librerie vulnerabili o lasciano trapelare dettagli di runtime possono diventare rapidamente incidenti di disponibilità (ad esempio, credenziali compromesse, downtime causato da exploit o amplificazione di denial-of-service). L'obiettivo di questo capitolo non è quindi rivendicare una ``sicurezza perfetta'', ma documentare un processo di hardening concreto e tracciabile applicato alla codebase di \textit{2Chance}.

L'analisi si è concentrata su tre dimensioni di valutazione complementari:
\begin{itemize}
  \item \textbf{Rilevamento Segreti (Secret detection)} a livello di repository (per prevenire l'esposizione accidentale di credenziali);
  \item \textbf{Analisi della Composizione del Software (SCA)} per dipendenze vulnerabili (rischio supply-chain);
  \item \textbf{Static Application Security Testing (SAST)} per pattern di codice rischiosi (programmazione difensiva ai punti di ingresso).
\end{itemize}

Il lavoro è stato condotto iterativamente seguendo il flusso: \textit{Scansione tramite pipeline CI in GitHub} $\rightarrow$ \textit{Correzione dei problemi} $\rightarrow$ \textit{Push sul repository} $\rightarrow$ \textit{Re-Iterazione}. Tutti gli output, le note e gli artefatti prima/dopo sono archiviati in \path{reports/evidence/security/}.

\section{Panoramica sugli Strumenti di Sicurezza}
In questo progetto, impieghiamo un approccio di sicurezza multi-livello utilizzando tre strumenti standard del settore, ognuno dei quali affronta una specifica dimensione della sicurezza software. Questa sezione fornisce una panoramica ad alto livello di questi strumenti prima di descrivere la loro integrazione specifica nella nostra pipeline.

\subsection{GitGuardian (Rilevamento Segreti)}
GitGuardian è una piattaforma progettata per rilevare informazioni sensibili (come chiavi API, credenziali database e certificati) che potrebbero essere accidentalmente committate nel controllo sorgente. Scansionando sia la storia di git che i commit in arrivo, previene la ``proliferazione di segreti'', assicurando che credenziali hardcoded non aggirino i controlli di accesso o trapelino a parti non autorizzate.

\subsection{Snyk (Analisi della Composizione del Software)}
Snyk è uno strumento di sicurezza developer-first che si concentra sulla Software Composition Analysis (SCA). Scansiona le dipendenze open-source (in questo caso, librerie Maven definite nel \texttt{pom.xml}) confrontandole con un database di vulnerabilità note (CVE). Aiuta a gestire il rischio della supply-chain identificando librerie obsolete o compromesse e suggerendo percorsi di aggiornamento o patch.

\subsection{SonarQube Cloud (Analisi Statica)}
SonarQube Cloud (precedentemente SonarCloud) è un servizio cloud-based di Static Application Security Testing (SAST) e qualità del codice. Analizza il codice sorgente alla ricerca di bug, vulnerabilità e code smells senza eseguire il programma. Nel contesto di questo progetto, è utilizzato in particolare per imporre standard di codifica sicura nell'implementazione Java, identificando pattern che potrebbero portare a problemi di affidabilità o sicurezza (ad esempio, gestione impropria delle eccezioni).

\section{Processo, Toolchain e Traccia delle Evidenze}
L'analisi di sicurezza è integrata nel workflow di GitHub Actions (\texttt{.github/workflows/main.yml}) e si basa sulla seguente toolchain:
\begin{itemize}
  \item \textbf{GitGuardian}: Eseguito immediatamente dopo il checkout del repository per rilevare segreti o credenziali nella codebase. Scansiona i commit (push e pull request) e impedisce il merge di dati sensibili.
  \item \textbf{Snyk}: Eseguito come step dedicato per identificare vulnerabilità nelle dipendenze Maven. La pipeline è configurata per fallire la build se vengono rilevati problemi di gravità \emph{High} o \emph{Critical} (\texttt{--severity-threshold=high}).
  \item \textbf{SonarQube Cloud}: Integrato nel ciclo di vita della build Maven (durante la fase \texttt{verify}). Esegue l'analisi statica del codice per rilevare bug, code smells e hotspot di sicurezza (inclusa l'analisi del layer controller menzionata successivamente).
\end{itemize}

Le evidenze sono organizzate per strumento:
\begin{itemize}
  \item \path{reports/evidence/security/gitguardian/} (output scansioni, correzioni, walkthrough);
  \item \path{reports/evidence/security/snyk/} (scansione baseline, scansione post-fix, modifiche dipendenze);
  \item \path{reports/evidence/security/sonar/} (export problemi CSV/JSON e walkthrough rimedio).
\end{itemize}

\subsection{Riepilogo Prima/Dopo}
La Tabella~\ref{tab:security-summary} riassume lo stato prima/dopo come catturato dai tre strumenti. I numeri sono presi dai report di baseline e dalle esecuzioni di verifica finale archiviate nelle cartelle delle evidenze.

\begin{table}[h]
\centering
\caption{Riepilogo valutazione sicurezza (prima/dopo) basato sulle evidenze archiviate.}
\label{tab:security-summary}
\begin{tabular}{l c c l}
\hline
\textbf{Strumento} & \textbf{Prima} & \textbf{Dopo} & \textbf{Esito} \\
\hline
GitGuardian & 6 occorrenze (Generic Password) & 0 & Risolto \\
Snyk & 14 problemi totali & 0 & Risolto \\
SonarQube Cloud & 96 problemi & 0 & Risolto \\
\hline
\end{tabular}
\end{table}

\section{Meccanismi di Sicurezza nella CI/CD (Checklist Item 0)}
Il repository include un workflow GitHub Actions completo (\path{.github/workflows/main.yml}) che impone controlli di sicurezza prima del deployment.
La pipeline definisce un job \texttt{build-secure-and-deploy} che esegue sequenzialmente:
\begin{enumerate}
    \item \textbf{Secret Scanning}: tramite action GitGuardian;
    \item \textbf{SCA}: tramite Snyk CLI;
    \item \textbf{Build \& SAST}: build Maven con analisi SonarQube;
    \item \textbf{Docker Build}: push dell'immagine solo se tutti gli step precedenti hanno successo.
\end{enumerate}
Questi controlli agiscono come ``quality gates'' automatizzati, assicurando che il codice che viola le policy di sicurezza (es. segreti esposti o vulnerabilità ad alta gravità) interrompa la build e prevenga il deployment.

\section{GitGuardian: Rilevamento Segreti e Rimedio}
\subsection{Perché la Scansione dei Segreti}
I segreti committati in un repository hanno un raggio d'azione sproporzionato: una singola password o token trapelato può abilitare accessi non autorizzati e aggirare molti altri controlli. La scansione dei segreti mira a prevenire questa classe di incidenti precocemente, prima che le credenziali vengano riutilizzate o propagate attraverso fork e cloni.

\subsection{Risultati Baseline}
La scansione baseline del repository GitGuardian ha rilevato \textbf{due istanze} della classe \emph{Generic Password}, per un totale di \textbf{sei occorrenze} distribuite su due file:
\begin{itemize}
  \item \path{src/prompts/03\_unit\_testing\_implementation.txt} (contenuto documentazione);
  \item \path{src/test/java/services/RegistrazioneServiceTest.java} (unit test).
\end{itemize}

Le evidenze grezze sono archiviate in:
\begin{itemize}
  \item \path{reports/evidence/security/gitguardian/ggshield\_repo\_scan.txt} (baseline);
  \item \path{reports/evidence/security/gitguardian/ggshield\_repo\_scan\_after\_cleanup.txt} (post-fix).
\end{itemize}

\subsection{Strategia di Rimedio e Razionale}
La strategia di rimedio è stata conservativa e pratica. Invece di limitarsi a ``segnare come sicuro'' nella dashboard, abbiamo applicato un approccio configuration-as-code per garantire la riproducibilità:

\paragraph{Modifiche alla Configurazione.}
È stato introdotto un file \path{.gitguardian.yaml} per gestire le esclusioni direttamente nel repository. Le modifiche principali includono:
\begin{itemize}
    \item \textbf{Esclusioni Percorsi}: \texttt{secret.ignored\_paths} è stato configurato per escludere \path{src/prompts/**} e unit test (\path{src/test/**}), distinguendo tra segreti reali e dati di test.
    \item \textbf{Pattern Matching}: \texttt{secret.ignored\_matches} è stato aggiornato per ignorare credenziali note di test (es. \texttt{Pass123!}, \texttt{validPassword}), riducendo il rumore dai vecchi mock di test.
\end{itemize}

Questa configurazione ha ridotto il rapporto segnale-rumore, assicurando che le scansioni future si concentrino su leak genuini.
Le modifiche applicate e le motivazioni sono documentate in:
\path{reports/evidence/security/gitguardian/security\_analysis\_gitguardian.md} e
\path{reports/evidence/security/gitguardian/gitguardian\_fixes.md}.

\subsection{Verifica}
Dopo la pulizia, GitGuardian ha riportato \textbf{0} segreti rilevati nella scansione del repository, come registrato in \path{ggshield\_repo\_scan\_after\_cleanup.txt}.

\section{Snyk: Valutazione Vulnerabilità Dipendenze (SCA)}
\subsection{Perché SCA}
Le applicazioni moderne ereditano una porzione significativa della loro superficie di attacco da librerie di terze parti. La Software Composition Analysis si concentra su vulnerabilità note (es. CVE) in dipendenze dirette e transitive. Il rimedio tipico consiste nell'aggiornare a una versione patchata o migrare a una coordinata artifact mantenuta.

\subsection{Risultati Baseline}
L'output della scansione baseline (\path{reports/evidence/security/snyk/snyk\_test.txt}) riporta \textbf{11 percorsi vulnerabili} al primo passaggio, che sono stati consolidati nelle note di analisi come \textbf{14 problemi totali} attraverso le fasi di rimedio. I componenti interessati si sono concentrati attorno a:
\begin{itemize}
  \item \texttt{commons-io:commons-io} (esaurimento risorse);
  \item \texttt{org.json:json} (problemi relativi a DoS);
  \item Connettore MySQL e la sua catena transitiva;
  \item JSTL (\texttt{javax.servlet:jstl}) (XXE e namespace legacy).
\end{itemize}

\subsection{Rimedio}
Sono stati applicati due tipi di correzioni:
\begin{itemize}
  \item \textbf{Aggiornamenti di versione} per artifact mantenuti (es. \texttt{commons-io} da \texttt{2.10.0} a \texttt{2.14.0}, \texttt{org.json:json} da \texttt{20210307} a \texttt{20231013});
  \item \textbf{Migrazione di artifact} dove la vecchia coordinata era deprecata o non patchata.
\end{itemize}

\paragraph{Migrazioni Critiche.}
Particolare attenzione è stata prestata a due risultati critici:
\begin{enumerate}
    \item \textbf{MySQL Connector}: Migrato da \texttt{mysql:mysql-connector-java} a \texttt{com.mysql:mysql-connector-j} (versione \texttt{9.5.0}) per risolvere vulnerabilità di Buffer Overflow nel driver legacy 8.x.
    \item \textbf{JSTL}: Sostituito il vulnerabile \texttt{javax.servlet:jstl} con \texttt{org.apache.taglibs:taglibs-standard-impl} (\texttt{1.2.5}) per risolvere i rischi di XXE Injection mantenendo la compatibilità con le API Servlet.
\end{enumerate}

Le modifiche esatte e le loro motivazioni sono documentate in:
\path{reports/evidence/security/snyk/security\_analysis\_snyk.md} e
\path{reports/evidence/security/snyk/snyk\_fixes.md}.

\subsection{Verifica}
Una scansione finale (\path{reports/evidence/security/snyk/snyk\_test\_after\_cleanup.txt}) riporta \textbf{0 problemi}. Inoltre, è stata eseguita una build completa e un ciclo di test per ridurre il rischio di regressioni legate alle dipendenze (vedi note correzioni Snyk; risultato suite di test: 533 test passati).

\section{SonarQube Cloud: Analisi Statica di Sicurezza sul Layer Controller}
\subsection{Perché SAST per Servlet}
L'analisi statica è particolarmente utile ai punti di ingresso dell'applicazione: nelle architetture basate su servlet, i metodi controller (\texttt{doGet}, \texttt{doPost}, hook del ciclo di vita) sono una fonte comune di propagazione incontrollata di eccezioni e perdita accidentale di informazioni. Anche quando il bug sottostante è ``solo'' un'eccezione, l'impatto di sicurezza è spesso pratico: stack trace e dettagli interni di errore possono rivelare la struttura del sistema e abilitare attacchi mirati.

\subsection{Risultati Baseline}
SonarQube Cloud ha segnalato \textbf{96 problemi} mappati alla regola \textbf{\texttt{java:S1989}} (``Exceptions should not be thrown by servlet methods''). Gli export grezzi sono archiviati in:
\begin{itemize}
  \item \path{reports/evidence/security/sonar/sonar\_security\_issues.csv} (iniziale);
  \item \path{reports/evidence/security/sonar/sonar\_security\_issues\_2.csv} (metà rimedio);
  \item \path{reports/evidence/security/sonar/sonar\_security\_issues\_final.csv} (finale).
\end{itemize}

\subsection{Pattern di Rimedio e Motivazione}
Il rimedio ha interessato \textbf{17 Controller Servlet} (inclusi \texttt{LoginServlet}, \texttt{AdminServlet} e \texttt{RegistrazioneServlet}). La correzione ha comportato un refactoring sistematico per impedire che eccezioni non controllate raggiungessero la pagina di errore di default del container.

\paragraph{Dettagli Implementativi.}
\begin{itemize}
    \item \textbf{Gestione Sicura Errori}: È stata introdotta una nuova utility \texttt{src/main/java/utils/ResponseUtils.java} per centralizzare le risposte di errore. Utilizza \texttt{ResponseUtils.sendError(response, status, message)} per gestire ricorsivamente le IOException, assicurando che un fallimento nel reporting dell'errore non mandi in crash la servlet.
    \item \textbf{Wrapping Standardizzato}: Tutti i metodi \texttt{doGet}, \texttt{doPost} e \texttt{init} sono stati avvolti in blocchi `try-catch`. Le eccezioni catturate vengono loggate e convertite in risposte di errore generiche 500, mascherando gli stack trace al client.
\end{itemize}

Il walkthrough completo e la lista file sono documentati in:
\path{reports/evidence/security/sonar/walkthrough\_sonar.md} e \path{reports/evidence/security/sonar/sonar\_fixes.md}.

\subsection{Verifica}
Gli export finali di Sonar riportano \textbf{0 problemi}. Una build Maven ed esecuzione completa della suite di test sono state eseguite dopo il refactoring (533/533 test passati), fornendo ulteriore confidenza che le modifiche preservino il comportamento.

\section{L'Applicazione Web Non Mostra Vulnerabilità (Checklist Item 2)}
Strumenti statici e scanner di dipendenze riducono il rischio, ma non sono sufficienti per affermare che l'applicazione web \emph{in esecuzione} ``non mostri vulnerabilità''. Questo punto della checklist dovrebbe essere indirizzato con un passaggio finale di verifica a livello di sistema (scansione dinamica e/o controlli manuali mirati) contro un'istanza deployata dell'applicazione.

\paragraph{Claim basato su evidenze (scope).}
Sulla base delle ri-scansioni finali, la campagna di sicurezza non riporta risultati rimanenti nel suo ambito: GitGuardian rileva 0 segreti nel repository, Snyk riporta 0 problemi noti di dipendenze vulnerabili e SonarQube Cloud riporta 0 occorrenze della regola \texttt{java:S1989}. Pertanto, all'interno dell'ambito di secret scanning + SCA + analisi statica, l'applicazione non mostra vulnerabilità rilevate.

\paragraph{Nota di completezza.}
Per completezza, può essere eseguita una verifica dinamica leggera (DAST) contro un deployment in esecuzione (es. scansione baseline degli endpoint esposti) e archiviata come evidenza aggiuntiva. Questo passaggio è raccomandato come controllo extra a livello di sistema, ma non è richiesto per supportare il claim limitato allo scope sopra citato.

\section{Minacce alla Validità}
\paragraph{Falsi positivi e interpretazione delle regole.}
Tutti e tre gli strumenti possono produrre falsi positivi o risultati che richiedono interpretazione contestuale. I risultati di GitGuardian su ``password generiche'' sono particolarmente sensibili alla documentazione e ai test; i report di Snyk possono cambiare con l'evolversi degli advisory; le regole Sonar possono segnalare pattern che sono benigni in contesti specifici. Per questo motivo, il triage umano è una parte esplicita del processo documentato.

\paragraph{Ambiente e riproducibilità.}
I risultati degli strumenti dipendono dal contesto di esecuzione: configurazioni locali, stato di autenticazione per le dashboard cloud e cronologia del repository. Per mitigare questo, gli output baseline e post-fix sono stati archiviati nel repository. Tuttavia, gli output esatti possono differire nel tempo a causa di database delle vulnerabilità aggiornati (Snyk) o regole dell'analizzatore aggiornate (Sonar).

\paragraph{Aggiornamenti dipendenze e drift comportamentale.}
L'aggiornamento delle dipendenze migliora la postura di sicurezza ma può introdurre sottili cambiamenti di compatibilità. Il progetto ha mitigato questo rischio ricostruendo ed eseguendo l'intera suite di test dopo il rimedio. Un drift comportamentale residuo è ancora possibile e dovrebbe essere monitorato in modifiche future.

\paragraph{Gap di copertura senza test dinamici.}
Senza la verifica finale del checklist item 2, la valutazione rimane incompleta al livello di runtime. I risultati statici e SCA dovrebbero essere interpretati come ``rischio ridotto'' piuttosto che ``nessuna vulnerabilità'' per l'applicazione deployata.

\section{Conclusioni e Passi Successivi}
Il lavoro di garanzia della sicurezza ha seguito un loop concreto scansione--correzione--verifica e ha prodotto evidenze archiviate nel repository per ogni strumento. Il progetto ha rimosso:
(i) pattern simili a segreti da documentazione/test e limitato i falsi positivi via \path{.gitguardian.yaml},
(ii) vulnerabilità delle dipendenze tramite aggiornamenti e migrazioni mirate di artifact,
e (iii) pattern rischiosi di propagazione eccezioni servlet introducendo una gestione degli errori lato controller coerente e una utility condivisa \texttt{ResponseUtils}.

I passi successivi immediati sono:
\begin{itemize}
  \item completare il checklist item 2 con una verifica dinamica/livello sistema finale e archiviare le evidenze grezze;
  \item (opzionale) estendere il workflow CI con job di sicurezza leggeri per imporre la scansione come parte della pipeline piuttosto che come passaggio manuale.
\end{itemize}

\section{Dati Mancanti}
Per finalizzare questo capitolo con la massima audibilita, i seguenti dettagli sarebbero utili:
\begin{itemize}
  \item Se le scansioni di sicurezza sono già integrate nella CI/CD oltre a build/test (e se sì, quali job e trigger);
  \item La procedura esatta e lo strumento scelto per il checklist item 2 (DAST/manuale), più output grezzi da archiviare;
  \item Come viene attivata l'analisi SonarQube Cloud nel tuo setup (esecuzione manuale dashboard vs integrazione CI), in modo che il metodo di esecuzione possa essere documentato con precisione.
\end{itemize}
